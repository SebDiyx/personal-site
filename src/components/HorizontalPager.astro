---
// Horizontal pager container. Expects children with class `slide`.
const { initialIndex = 0 } = Astro.props as { initialIndex?: number };
---

<div id="horizontal-pager" class="relative w-screen h-screen overflow-hidden">
  <div class="slides flex h-full transition-transform duration-500 ease-in-out will-change-transform no-scrollbar">
    <slot />
  </div>

  <div class="pager-dots absolute bottom-6 left-1/2 -translate-x-1/2 flex items-center gap-2 z-30"></div>

  <div class="absolute inset-x-0 top-0 z-30">
    <slot name="overlay" />
  </div>
</div>

<script is:inline define:vars={{ initialIndex }}>
  // Basic, dependency-free pager with wheel, keys, touch, and anchor support
  const initHorizontalPager = () => {
    const pagerEl = document.getElementById('horizontal-pager');
    if (!pagerEl) {
      console.warn('[HorizontalPager] container not found');
      return;
    }
    const slidesEl = pagerEl.querySelector('.slides');
    const slideEls = Array.from(pagerEl.querySelectorAll('.slide'));
    const dotsEl = pagerEl.querySelector('.pager-dots');

    let currentIndex = Math.min(
      Math.max(0, Number(initialIndex) || 0),
      slideEls.length - 1
    );
    let animating = false;

    const setActiveClasses = () => {
      slideEls.forEach((s, i) => s.setAttribute('aria-hidden', i === currentIndex ? 'false' : 'true'));
      const dotButtons = Array.from(dotsEl.querySelectorAll('button'));
      dotButtons.forEach((b, i) => {
        if (i === currentIndex) {
          b.classList.add('bg-accent', 'w-3');
          b.classList.remove('bg-border', 'w-2.5');
          b.setAttribute('aria-current', 'true');
        } else {
          b.classList.remove('bg-accent', 'w-3');
          b.classList.add('bg-border', 'w-2.5');
          b.removeAttribute('aria-current');
        }
      });
    };

    const applyTransform = (idx) => {
      slidesEl.style.transform = `translateX(-${idx * 100}vw)`;
    };

    const goTo = (idx, updateHash = true) => {
      const target = Math.max(0, Math.min(idx, slideEls.length - 1));
      if (target === currentIndex || animating) return;
      animating = true;
      currentIndex = target;
      applyTransform(currentIndex);
      setActiveClasses();
      const targetId = slideEls[currentIndex] && slideEls[currentIndex].id;
      if (updateHash && targetId) {
        history.replaceState(null, '', `#${targetId}`);
      }
      window.setTimeout(() => {
        animating = false;
      }, 550);
    };

    // Size slides container and initialize dots
    dotsEl.innerHTML = '';
    // Ensure each slide has correct sizing class in case missing
    slideEls.forEach((el) => el.classList.add('slide'));
    slidesEl.style.width = `${slideEls.length * 100}vw`;
    slideEls.forEach((_s, i) => {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'h-2.5 w-2.5 rounded-full bg-border transition-all focus:outline-none focus:ring-2 focus:ring-accent/40';
      btn.setAttribute('aria-label', `Go to page ${i + 1}`);
      btn.addEventListener('click', () => goTo(i));
      dotsEl.appendChild(btn);
    });

    // Wheel -> horizontal paging (debounced)
    let wheelAccumulator = 0;
    let wheelTimeout = null;
    const WHEEL_THRESHOLD = 40; // sensitivity
    const onWheel = (e) => {
      e.preventDefault();
      wheelAccumulator += Math.abs(e.deltaY) > Math.abs(e.deltaX) ? e.deltaY : e.deltaX;
      if (wheelTimeout) window.clearTimeout(wheelTimeout);
      wheelTimeout = window.setTimeout(() => {
        if (Math.abs(wheelAccumulator) > WHEEL_THRESHOLD) {
          if (wheelAccumulator > 0) goTo(currentIndex + 1);
          else goTo(currentIndex - 1);
        }
        wheelAccumulator = 0;
        wheelTimeout = null;
      }, 50);
    };
    pagerEl.addEventListener('wheel', onWheel, { passive: false });
    window.addEventListener('wheel', (e) => {
      // If event originated inside pager, handle even if overlay element captured it
      const targetEl = e.target;
      // @ts-ignore plain JS runtime
      if (targetEl && pagerEl.contains(targetEl)) onWheel(e);
    }, { passive: false });

    // Key navigation
    window.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowRight' || e.key === 'PageDown') goTo(currentIndex + 1);
      if (e.key === 'ArrowLeft' || e.key === 'PageUp') goTo(currentIndex - 1);
      if (e.key === 'Home') goTo(0);
      if (e.key === 'End') goTo(slideEls.length - 1);
    });

    // Touch swipe
    let touchStartX = 0;
    let touchStartY = 0;
    pagerEl.addEventListener('touchstart', (e) => {
      const t = e.touches[0];
      touchStartX = t.clientX;
      touchStartY = t.clientY;
    }, { passive: true });
    pagerEl.addEventListener('touchend', (e) => {
      const t = e.changedTouches[0];
      const dx = t.clientX - touchStartX;
      const dy = t.clientY - touchStartY;
      if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 30) {
        if (dx < 0) goTo(currentIndex + 1);
        else goTo(currentIndex - 1);
      }
    });

    // Anchor navigation (links like #projects) anywhere in the document
    document.addEventListener('click', (e) => {
      const targetEl = e.target;
      if (!targetEl) return;
      const link = targetEl.closest('a[href^="#"]');
      if (!link) return;
      const id = link.getAttribute('href')?.slice(1);
      if (!id) return;
      const idx = slideEls.findIndex((s) => s.id === id);
      if (idx >= 0) {
        e.preventDefault();
        goTo(idx);
      }
    });

    // Hash -> slide on load
    const hash = window.location.hash.replace('#', '');
    const initialIdx = hash ? slideEls.findIndex((s) => s.id === hash) : -1;
    applyTransform(initialIdx >= 0 ? initialIdx : currentIndex);
    if (initialIdx >= 0) currentIndex = initialIdx;
    setActiveClasses();
  };

  if (document.readyState === 'loading') {
    window.addEventListener('DOMContentLoaded', initHorizontalPager, { once: true });
  } else {
    initHorizontalPager();
  }
</script>
